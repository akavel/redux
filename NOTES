Working notes which will slowly get out of date...

    procedure outdate-dependents(dependency-type, target)
        for each dependent of type dependency-type on target
            mark dependent as out of date
            
    procedure add-file-record(file do-file timestamp hash)
        # note: do-file is nil when file is source, not target
        add record

    procedure update-file-record(file do-file timestamp hash)
        update record
           
    procedure delete-file-record(file)
        delete file record
        [call procedure outdate-dependents 'ifcreate' file]
        delete dependency records to file
        delete dependency records from file
        
        
    procedure run-do-file(target do-file)
        run do-file [1]
        # check for multiple outputs...
        
        created = record.hash == nil
        if result.hash != record.hash
           save new file
           update target record(target do-file exit-status content-hash timestamp)
           if created
              [call procedure outdate-dependents 'ifcreate' file]
              
           [call procedure outdate-dependents 'ifchange' file]
           
    procedure file-timestamp-changed (record file)
       file.timestamp != record.timestamp
       
    procedure file-hash-changed(record file)
       file.hash != record.hash
       
    procedure file-changed?(record file)
       file-timestamp-changed?(record file) or file-hash-changed(record file)


    procedure redo-target(target, do-file, do-files-not-found)
              [call procedure redo-ifchange(target, do-file)]
              for each file in do-files-not-found
                  [call procedure redo-ifcreate(target, file)]
              [call procedure run-do-file target do-file]
              
    procedure is-doable?(record)
              record.do_file != nil
              
    procedure redo(target file)
      do-file, do-files-not-found = find-do-file(target)
      record, record-found? = find-file-record(target)
      
      if target file exists
          if record-found?
              if do-file
                  [call procedure redo-target target do-file do-files-not-found]
              else if is-doable?(record)
                  error "Missing do file for target" (note: 3)
              else if file-changed?(record target) #target is a source file
                   [call procedure update-file-record target]
                   [call procedure outdate-dependents 'ifchange' target]
          else
              if do-file
                  [call procedure redo-target target do-file do-files-not-found]
              else #target is source
                  [call procedure add-file-record target]
                  [call procedure outdate-dependents 'ifcreate' target]
              
      else # target file does not exist
          if record-found?
              # existed at one point but was deleted
              [call procedure outdate-dependents 'ifcreate' file]
              if do-file
                 [call procedure redo-target target do-file do-files-not-found]
              else if is-doable?(record)
                 error "cannot find do file for target"
              else # target is a deleted source file
                 [call procedure outdate-dependents 'ifchange' target]          
                 [call procedure forget-file target]
                 error "source file does not exist"
          else
              if do-file
                 [call procedure redo-target target do-file do-files-not-found]
              else
                error "cannot redo unknown file: target file"
            
Notes:

[1] In the special case where a class of targets are generated by a default.do file,
but some files are 'source' files and not generated, it is necessary for the default.do
file to recognize the special case and 'generate' the file with cat.

[2] If a more specific do file is created for a file, 
the current redo-ifcreate rule (for the less specific file) would be invoked once.
but the rules should then be changed to 'redo-ifchange do file' for the more specific
This can be accomplished by deleting the old set and generating a new set.

[3] This implies a need for the command '`redo-forget` target' to remove a target's record from the
database.

[4] In this implementation, the case where a more specific do file is added and the less specific
one modified will cause both scripts to mark the target as out of date.


# redo-static

Static or source files represent leaf nodes in the dependency graph.
They do not have dependencies on other files.  However, since they are
edited, they do change and must be tracked in order to trigger dependency
actions. When 

  procedure redo-static(target)
            [call procedure update-file-record record target]
            [call procedure outdate-dependents "if-change" target]
                 

   procedure out-of-date?(target)

       if not file-exists? target
          return true

       record, record-found? = find-file-record(target)
       if not record-found?
          return true

       if record.outdated?
          return true
          
       if file-changed?(record, target)
          return true
             
       if any? (dependencies file) changed?
             return true

          
   procedure redo-ifchange(target)

       ensure-dependency-record((get-env "REDO-TARGET") "ifchange" target)
       
       if out-of-date?(target)
          do-file, do-files-not-found = find-do-file(target)
          if do-file
             [call procedure run-do-file target do-file]
          else
            record = find-file-record(target)
            if is-doable?(record)
                 error "Missing do file for target"
            else if file-changed(record, target)
                 [call procedure redo-static target]


Notes:
[1] This means that unchanging 'source' files will always be considered to be out of date
only to be left unchanged by the `redo` algorithm. While this seems wasteful, it does serve
the purpose of allowing the redo algorithm to detect when a source file is changed to a generated
one.  


# redo-forget

The `redo-forget` command is used to clear database records for targets that have been deleted.
It is invoked as `redo-forget TARGET...`

This has not been written yet.

